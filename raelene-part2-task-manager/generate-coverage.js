/**
 * This script converts Playwright V8 frontend coverage
 * into Istanbul format and generates an HTML coverage report.
 *
 * Additional Feature:
 * - Enforces a minimum frontend coverage threshold.
 * - The script will FAIL if coverage is below the defined level.
 */

const fs = require("fs").promises;
const path = require("path");
const v8toIstanbul = require("v8-to-istanbul");
const reports = require("istanbul-reports");
const { createContext } = require("istanbul-lib-report");
const { createCoverageMap } = require("istanbul-lib-coverage");

/**
 * Directory where Playwright stores raw V8 coverage data
 */
const coverageDir = path.join(process.cwd(), "coverage", "temp");

/**
 * Directory where the final frontend coverage report will be generated
 */
const istanbulCoverageDir = path.join(process.cwd(), "coverage", "frontend");

/**
 * Only include frontend JavaScript files that belong to MY feature.
 * This ensures coverage focuses on my own implementation only.
 */
const INCLUDE_JS = [
  "/js/raelene-cha.js"
];

/**
 * Extra safety check to exclude teammates' files
 * even if they are accidentally picked up.
 */
const EXCLUDE_KEYWORDS = ["ayana", "hamsitha", "shahina"];

/**
 * Additional Feature:
 * Define minimum coverage thresholds.
 * If coverage is below these values, the script will fail.
 */
const THRESHOLDS = {
  lines: 80,
  statements: 80,
  functions: 80,
  branches: 70
};

async function convertCoverage() {
  /**
   * Exit early if no Playwright coverage data exists.
   * This prevents errors when tests are not run with coverage enabled.
   */
  try {
    await fs.access(coverageDir);
  } catch {
    console.log("No coverage data found.");
    return;
  }

  /**
   * Create an empty Istanbul coverage map
   */
  const coverageMap = createCoverageMap();

  /**
   * Read all V8 coverage JSON files generated by Playwright
   */
  const files = await fs.readdir(coverageDir);

  for (const file of files) {
    if (!file.endsWith(".json")) continue;

    const v8Coverage = JSON.parse(
      await fs.readFile(path.join(coverageDir, file), "utf-8")
    );

    for (const entry of v8Coverage) {
      if (!entry.url || !entry.source) continue;

      /**
       * Safely extract the file path from the coverage entry URL
       */
      let pathname;
      try {
        pathname =
          entry.url.startsWith("http") || entry.url.startsWith("file://")
            ? new URL(entry.url).pathname
            : entry.url;
      } catch {
        pathname = entry.url;
      }

      /**
       * Skip:
       * - Non-JavaScript files
       * - External scripts
       * - node_modules
       */
      if (
        !pathname.endsWith(".js") ||
        (entry.url.startsWith("http") && !entry.url.includes("localhost")) ||
        entry.url.includes("node_modules")
      ) {
        continue;
      }

      /**
       * Only include my own frontend feature 
       */
      const isIncluded = INCLUDE_JS.some((p) => pathname.endsWith(p));
      if (!isIncluded) continue;

      /**
       * Exclude teammates' files
       */
      const lower = pathname.toLowerCase();
      if (EXCLUDE_KEYWORDS.some((k) => lower.includes(k))) continue;

      /**
       * Handle Windows file paths correctly
       */
      const filePath = entry.url.startsWith("file://")
        ? pathname.replace(/^\/([a-zA-Z]:)/, "$1")
        : pathname;

      try {
        /**
         * Convert V8 coverage into Istanbul format
         * using the original source code
         */
        const converter = v8toIstanbul("public/" + filePath, 0, {
          source: entry.source,
        });

        await converter.load();
        converter.applyCoverage(entry.functions);
        coverageMap.merge(converter.toIstanbul());
      } catch (err) {
        console.warn(`Skipping coverage for ${entry.url}: ${err.message}`);
      }
    }
  }

  /**
   * Stop if no valid coverage data was converted
   */
  if (!Object.keys(coverageMap.data).length) {
    console.log("No coverage data was converted.");
    return;
  }

  /**
   * Ensure output directory exists
   */
  await fs.mkdir(istanbulCoverageDir, { recursive: true });

  /**
   * Generate HTML and LCOV coverage reports
   */
  const context = createContext({ dir: istanbulCoverageDir, coverageMap });
  ["html", "lcovonly"].forEach((type) =>
    reports.create(type).execute(context)
  );

  console.log(`Coverage report generated in ${istanbulCoverageDir}`);

  /**
   * ================= ADDITIONAL FEATURE =================
   * Coverage Threshold Enforcement
   *
   * This ensures frontend tests meet a minimum quality level.
   * The script will fail if coverage is below the required threshold.
   */
  const summary = coverageMap.getCoverageSummary();
  // Extract actual coverage percentages
  const results = {
    lines: summary.lines.pct,
    statements: summary.statements.pct,
    functions: summary.functions.pct,
    branches: summary.branches.pct,
  };
  // Check against thresholds
  let failed = false;
  // Display results
  console.log("\nFrontend Coverage Summary:");
  // For each metric
  for (const key in THRESHOLDS) {
    const actual = results[key];
    const required = THRESHOLDS[key];
    // Display each metric
    console.log(`${key}: ${actual}% (required: ${required}%)`);
    // Check if below threshold
    if (actual < required) {
      failed = true;
    }
  }
  // Exit with failure if any threshold not met
  if (failed) {
    console.error("\nCoverage threshold not met.");
    process.exit(1);
  }
  // If all thresholds met
  console.log("\nCoverage threshold met.");
}

convertCoverage();
